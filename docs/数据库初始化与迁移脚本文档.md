针对 **LOGOS (智能规则中台)** 项目，基于业务专家提供的 MVP 建模（实体、属性、动作、关系），以下是完整的 **数据库初始化与迁移脚本文档**。

---

# LOGOS 数据库初始化与迁移脚本文档

## 1. Neo4j Cypher 完整初始化脚本

该脚本用于构建底层本体架构，将业务专家的“五元组”建模落地为图数据库结构。

### 1.1 环境清理与约束设置

```cypher
// 清理存量数据（仅限初始化阶段）
// MATCH (n) DETACH DELETE n;

// 创建唯一性约束，确保实体编码和属性路径不重复
CREATE CONSTRAINT entity_code IF NOT EXISTS FOR (e:Entity) REQUIRE e.code IS UNIQUE;
CREATE CONSTRAINT metadata_id IF NOT EXISTS FOR (m:Metadata) REQUIRE m.id IS UNIQUE;
CREATE CONSTRAINT constraint_id IF NOT EXISTS FOR (b:BusinessConstraint) REQUIRE b.id IS UNIQUE;

```

### 1.2 核心本体层初始化 (Concepts & Meta)

```cypher
// 1. 创建核心实体节点
MERGE (c:Entity {code: 'RuleContext', name: '规则上下文', desc: '输入参数与执行环境'})
MERGE (p:Entity {code: 'ProdInst', name: '产品实例', desc: '规则检查的目标对象'})
MERGE (b:Entity {code: 'BusinessConstraint', name: '业务约束', desc: '业务逻辑与判断条件'})

// 2. 建立实体间的基础关系拓扑
MATCH (c:Entity {code: 'RuleContext'}), (p:Entity {code: 'ProdInst'}), (b:Entity {code: 'BusinessConstraint'})
MERGE (c)-[:appliesTo]->(p)
MERGE (p)-[:isConstrainedBy]->(b)
MERGE (b)-[:matches]->(p);

// 3. 注册全局原子动作 (Action)
MERGE (a1:Action {code: 'ShouldSkipCheck', handler: 'LogosUtils.shouldSkip'})
MERGE (a2:Action {code: 'ValidateConstraint', handler: 'LogosEngine.validate'})
MERGE (a3:Action {code: 'BlockExecution', handler: 'Errors.error'});

```

### 1.3 业务资产层初始化 (实例数据：以灵犀专线为例)

```cypher
// 1. 映射物理属性到元数据节点
MATCH (p:Entity {code: 'ProdInst'})
MERGE (m1:Metadata {id: 'businessTypeCode', name: '业务类型编码', path: 'COL1', type: 'String'})-[:BELONGS_TO]->(p)
MERGE (m2:Metadata {id: 'prodId', name: '产品规格ID', path: 'PROD_ID', type: 'String'})-[:BELONGS_TO]->(p)

MATCH (ctx:Entity {code: 'RuleContext'})
MERGE (m3:Metadata {id: 'soId', name: '服务提供ID', path: 'orderRequest.serviceOfferId', type: 'String'})-[:BELONGS_TO]->(ctx)
MERGE (m4:Metadata {id: 'operType', name: '操作类型', path: 'orderRequest.operType', type: 'String'})-[:BELONGS_TO]->(ctx);

// 2. 创建具体的业务约束 (融合光网准入规则)
MERGE (bc:BusinessConstraint {
    id: 'BC_LX_001',
    name: '灵犀融合光网约束',
    targetProductId: '80000122',
    targetBusinessType: '3',
    allowedActions: '2831',
    exemptOperTypes: '["1100", "1200"]',
    errorMessage: '灵犀专线业务类型为融合光网时，只允许做拆机操作'
});

```

---

## 2. 数据字典（字段映射表）

此表作为 **LLM RAG 检索** 的核心参考，确保自然语言生成的变量名与物理代码一致。

| 语义名称 | 逻辑编码 (SpEL 变量) | 物理来源 (Java Path/DB Col) | 所属实体 | 说明 |
| --- | --- | --- | --- | --- |
| **操作类型** | `operType` | `orderRequest.getOperType()` | `RuleContext` | 1200=变更, 1100=新装 |
| **产品规格** | `prodId` | `accessProdInst.getProdId()` | `ProdInst` | 灵犀专线=80000122 |
| **业务类型** | `businessTypeCode` | `accessProdInst.getAttr("COL1")` | `ProdInst` | 3=融合光网 |
| **服务提供** | `serviceOfferId` | `orderRequest.getServiceOfferId()` | `RuleContext` | 2831=拆机 |
| **动作类型** | `actionType` | `accessProdInst.getActionType()` | `ProdInst` | A=新增, M=修改, D=删除 |

---

## 3. 版本升级与迁移路径

为了保证从传统 Java 代码向 LOGOS 语义规则平滑迁移，设定以下三个阶段：

### V1.0 - 语义感知阶段 (MVP)

* **目标**：建立本体模型，实现“硬编码”到“图映射”的转化。
* **迁移动作**：
1. 运行上述 Cypher 初始化脚本。
2. 将 `LinXiInitCheckRule` 等 7 个插件涉及的物理字段录入 `Metadata` 节点。



### V2.0 - 自动化生成阶段 (LLM + RAG)

* **目标**：接入 LLM，实现 NL2SpEL 自动生成。
* **迁移动作**：
1. 部署 LLM 适配层，接入 GPT-4/DeepSeek。
2. 建立 Prompt 模板库，关联图谱中的 `Metadata` 检索链路。



### V3.0 - 闭环治理阶段 (Full Lifecycle)

* **目标**：实现“可解释、可验证、可管理”的闭环。
* **迁移动作**：
1. 启用规则执行日志回写 Neo4j，支持逻辑执行路径追溯。
2. 建立规则版本节点，支持一键回滚。



---

## 4. 迁移验证清单 (Checklist)

1. **语法一致性**：检查 Neo4j 中 `Metadata.path` 是否与现网 Java 类的 Getter 路径 100% 匹配。
2. **逻辑覆盖**：验证 `BusinessConstraint` 节点的 `exemptOperTypes` 属性是否覆盖了原代码中的所有 `if` 拦截跳过条件。
3. **连通性**：通过 React 前端执行 `MATCH (n) RETURN n` 确保中间件链路通畅。

**本脚本已严格遵循专家设计的“五元组”逻辑。您可以直接将其部署到开发环境执行。是否需要我为您编写配套的 Java 迁移工具类，用于自动从旧配置表中同步数据到 Neo4j？**